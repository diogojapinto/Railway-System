class TestVendingMachine is subclass of MyTestCase
/*
  Contains the test definitions for the vending machine.
  Illustrates a scenario-based testing approach.
  Also illustrates the usage of assertions and '||'.
  JPF, FEUP, MFES, 2014/15.
*/

operations
	/***** USAGE SCENARIOS ******/
	
	-- Scenario: Normal purchase scenario in a vending machine.
	-- Pre-conditions:
	--  1. The machine is initially idle. (initial system state)
	--  2. The machine has the product in stock. (initial system state)
	--  3. The buyer has enough coins. (input)
	--  4. If needed, the machine has coins in stock to give change. (initial system state)
	-- Post-conditions:
	--  1. The buyer received the product. (output)
	--  2. The buyer received the change, if needed. (output)
	--  3. The stock of the product is updated in the machine. (final system state)
	--  4. The stock of coins is updated in the machine. (final system state)
	--  5. The machine is idle again. (final system state)
	-- Steps:
	--   1. The buyer inserts the coins.
	--   2. The machine displays the money inserted (credit).
	--   3. The buyer selects the product.
	--   4. The machine delivers the product and the change, if needed.
	--   5. The buyer picks the product and the change, if existent
	public PurchaseScn: VendingMachine * Product * MoneyUtils`BagOfCoins 
					==> [Product] * MoneyUtils`BagOfCoins
	PurchaseScn(vm, prod, coins) == (
		dcl inserted : nat := 0;
		dcl deliveredProd : [Product] := nil;
		dcl change : MoneyUtils`BagOfCoins := {|->};		
		for all c in set dom coins do
			for all - in set {1 , ..., coins(c)} do (
				vm.insertCoin(c);
				inserted := inserted + c;
				assertEqual(inserted, vm.amountInserted)
      );      		
    vm.selectProduct(prod);    
    || (deliveredProd := vm.pickProduct(), 
    	  if MoneyUtils`sum(coins) > prod.price then change := vm.pickChange());
    return mk_(deliveredProd, change)
	)
	pre vm.status = <Idle> /*1*/
		  and (prod in set vm.products and prod.quantityInStock > 0) /*2*/
	    and MoneyUtils`sum(coins) >= prod.price /*3*/ 
	    and MoneyUtils`canExtract2(MoneyUtils`addAll(vm.stockOfCoins, coins), 
	                              MoneyUtils`sum(coins) - prod.price) /*4*/	   
	post let mk_(deliveredProd, change) = RESULT in (
				 deliveredProd = prod /*1*/
				 and MoneyUtils`sum(change) = MoneyUtils`sum(coins) - prod.price /*2*/
				 -- post-conditions not supported (old state of referenced object)
				 -- and vm.stockOfProducts(prod) = vm.stockOfProducts~(prod)-1 /*3*/
				 -- and vm.stockOfCoins = MoneyUtils`removeAll(change, 
				 --								MoneyUtils`addAll(vm.stockOfCoins~, coins)) /*4*/
			  and vm.status = <Idle> /*5*/
			);
	
	-- Scenario: Exceptional buying scenario in which the user cancels the purchase.
	-- Pre-conditions:
	--  1. The machine is initially idle. (initial system state)
	--  2. The buyer has some coins to insert. (input)
	-- Post-conditions:
	--  1. The buyer received back the amount inserted (same or equiv coins). (output)
	--  2. The amount of money is unchanged in the machine. (final system state)
	--  3. The machine is idle again. (final system state)
	-- Steps:
	--   1. The buyer inserts the coins.
	--   2. The machine displays the money inserted (credit).
	--   3. The buyer cancels the operation.
	--   4. The machine returns back the coins inserted .
	--   5. The buyer picks the coins.
	public CancelScn: VendingMachine * MoneyUtils`BagOfCoins ==> MoneyUtils`BagOfCoins
	CancelScn(vm, coins) == (
		dcl inserted : nat := 0;
		for all c in set dom coins do
			for all - in set {1 , ..., coins(c)} do (
				vm.insertCoin(c);
				inserted := inserted + c;
				assertEqual(inserted, vm.amountInserted)
      );      		
    vm.cancel();    
    return vm.pickChange()
	)
	pre  vm.status = <Idle> /*1*/
	     and MoneyUtils`sum(coins) > 0 /*2*/ 
	post MoneyUtils`sum(RESULT) = MoneyUtils`sum(coins) /*1*/
			 -- post-condition not supported (old state of referenced object)
			 -- MoneyUtils`sum(vm.stockOfCoins) = MoneyUtils`sum(vm.stockOfCoins~) /*2*/
			  and vm.status = <Idle>; /*3*/

	-- Scenario: Normal scenario for loading (adding) products and 
	--     setting (adding/removing) the stock of a coins in a vending machine
	-- Pre-conditions:
	--   1. The machine is idle. (initial internal state)
	--   2. The operator knows the unlock code. (input)
	--   3.  The machine accepts the products to load. (input)
	-- Post-conditions:
	--   1. The items are added to the stock of products. (final internal state)
	--   2. The stock of coins is set to the intended one. (final internal state)
	--   3. The machine is idle again. (final internal state)
	-- Steps:
	--   1. Unlock and open the machine door.
	--   2. Set the stock of coins and products, by any order.
	--   3. Close and lock the machine door.
	public LoadStockScn: VendingMachine * seq of char * map Product to nat  * MoneyUtils`BagOfCoins ==> ()
	LoadStockScn(vm, code, prods, coins) ==
	(
		vm.openDoor(code);
		|| (vm.loadProducts(prods), vm.loadCoins(coins));		
		vm.closeDoor()
  )
  pre vm.status = <Idle> /*1*/
  		and code = vm.unlockingCode /*2*/
  		and dom prods subset vm.products /*3*/
  post -- not supported:
       -- forall p in set dom prods & 
       --    p.quantityInStock = p.quantityInStock~ + prods(p) /*1*/
  	   vm.stockOfCoins = coins /*2*/
  	   and vm.status = <Idle>; /*3*/

	/***** TEST CASES WITH VALID INPUTS ******/
	  	   
  -- Test case in which we initialize a vending machine and
  -- then buy two products, the first one with exact money and 
  -- the second one with change.	   
  public testLoadAndBuy: () ==> ()
  testLoadAndBuy() == (
  	dcl p1 : Product := new Product("Bolicao", 50);
  	dcl p2 : Product := new Product("Bongo", 70); 
  	dcl code : seq of char := "xa1!";
  	dcl vm : VendingMachine := new VendingMachine(code, {p1, p2});  		
  	LoadStockScn(vm, code, {p1 |-> 1, p2 |-> 1}, { |-> });
  	
  	let mk_(-, change) = PurchaseScn(vm, p1, {20 |-> 2, 10 |-> 1})
    in assertEqual({ |-> }, change);
    
  	let mk_(-, change) = PurchaseScn(vm, p2, {20 |-> 4})
    in assertEqual({10 |-> 1}, change)
  );

  -- Test case in which we initialize a vending machine and
  -- then enter coins and cancel.	  
  public testLoadAndCancel: () ==> ()
  testLoadAndCancel() == (
  	let p1 = new Product("Bolicao", 50),
  	    code = "xa1!",
  	    vm  = new VendingMachine(code, {p1}),  	  		
  	    coins = {20 |-> 2, 10 |-> 1}
  	in (
  	  LoadStockScn(vm, code, {p1 |-> 1}, { |-> });  	
  	  assertEqual(coins,  CancelScn(vm, coins))
  	)
  );
    
  -- Entry point that runs all tests with valid inputs
  public testAll: () ==> ()
  testAll() == (
  	testLoadAndBuy();
  	testLoadAndCancel();
  );

	/***** TEST CASES WITH INVALID INPUTS (EXECUTE ONE AT A TIME) ******/
	public testCannotMakeChange: () ==> ()
	testCannotMakeChange() == ( 	   
  	let p1 = new Product("Bolicao", 50),
  	    code = "xa1!",
  	    vm  = new VendingMachine(code, {p1})  	  		
  	in (
  	  LoadStockScn(vm, code, {p1 |-> 1}, { |-> });  	
  	  vm.insertCoin(100);
  	  vm.selectProduct(p1); -- breaks pre-condition
  	)
  );
  
  public testProductOutOfStock: () ==> ()
	testProductOutOfStock() == ( 	   
  	let p1 = new Product("Bolicao", 50),
  	    code = "xa1!",
  	    vm  = new VendingMachine(code, {p1})  	  		
  	in (
  	  LoadStockScn(vm, code, {p1 |-> 0}, { |-> });  	
  	  vm.insertCoin(50);
  	  vm.selectProduct(p1); -- breaks pre-condition
  	)
  );
   
  public testForgotToPickProduct: () ==> ()
	testForgotToPickProduct() == ( 	   
  	let p1 = new Product("Bolicao", 50),
  	    code = "xa1!",
  	    vm  = new VendingMachine(code, {p1})  	  		
  	in (
  	  LoadStockScn(vm, code, {p1 |-> 1}, { |-> });  	
  	  vm.insertCoin(50);
  	  vm.selectProduct(p1); 
  	  -- forgot: vm.pickProduct();
  	  vm.insertCoin(50); -- breaks pre-condition
  	)
  );    

  public testForgotToPickChange: () ==> ()
	testForgotToPickChange() == ( 	   
		let p1 = new Product("Bolicao", 50),
  	    code = "xa1!",
  	    vm  = new VendingMachine(code, {p1})  	  		
		in (
  	  LoadStockScn(vm, code, {p1 |-> 1}, { |-> });  	
  	  vm.insertCoin(50);
  	  vm.cancel(); 
			-- forgot: vm.pickChange();
  	  vm.insertCoin(50); -- breaks pre-condition
		)
	);    
  
end TestVendingMachine