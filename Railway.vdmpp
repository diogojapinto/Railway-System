class Railway
types
	public Direction = <CLOCKWISE> | <COUNTER_CLOCKWISE>;
	public Train :: id          : token
									isAtStation : bool
									dir         : Direction;
values
instance variables
	public static trainCounter: nat := 0;
	
	private isClosed: bool := false;
	
	public trackElements: seq of TrackElement := [];
	public trains: set of Train := {};
	
	inv trainCounter = card trains;
operations

	--------------------
	--   Build ops    --
	--------------------
	
	----- adds an element to the end of the current track -----
	public appendTrackElement: TrackElement ==> ()
	appendTrackElement(newTrackElem) == (
		if len trackElements > 0 then (
			-- set elements ordering
			newTrackElem.nextCounterClockwise := trackElements(len trackElements);
			trackElements(len trackElements).nextClockwise := newTrackElem;
		);
		
		-- add to sequence
		trackElements := trackElements ^ [newTrackElem];
	)
	pre
		len trackElements > 0 and isofclass(Station, newTrackElem) => not isofclass(Station, trackElements(len trackElements)) and
		isClosed = false
	post
		len trackElements = (len trackElements~ + 1) and
		len trackElements > 1 => trackElements(len trackElements - 1).nextClockwise = trackElements(len trackElements) and
		len trackElements > 1 => trackElements(len trackElements).nextCounterClockwise = trackElements(len trackElements - 1);
		
	
	----- terminates the construction of the track -----
	public closeTrack: () ==> seq of TrackElement
	closeTrack() == (
		trackElements(len trackElements).nextClockwise := trackElements(1);
		trackElements(1).nextCounterClockwise := trackElements(len trackElements);
		initSemaphores();
		isClosed := true;
		return trackElements;
	)
	pre
		isClosed = false
	post
		trackElements(1).nextCounterClockwise = trackElements(len trackElements) and
		trackElements(len trackElements).nextClockwise = trackElements(1);
	
	public placeTrain: nat * Direction ==> ()
	placeTrain(index, dir) == (
		dcl newTrain: Train := mk_Train(mk_token(trainCounter), false, dir);
		atomic(
			trains := trains union {newTrain};
			trainCounter := trainCounter + 1;
		);
		
		trackElements(index).placeTrain(newTrain);
	);
	
	
	----- initializes all semaphores -----
	private initSemaphores: () ==> ()
	initSemaphores() == (
		for all elem in set elems trackElements do (
			elem.initSemaphores()
		)
	)
	pre isClosed = false;
	
	----- initializes all semaphores -----
	public askToLeaveStation: Train ==> bool
	askToLeaveStation(train) == (
		dcl station: Station := iota s in set elems trackElements & s.hasTrain(train);
		dcl remainingTrains: set of Train := trains \ {train};
		if train.dir = <CLOCKWISE> then (
			if not station.nextClockwise.hasAnyTrain() then
				return false
			else
				moveTrain(train, station, station.nextClockwise);
		)
		else (
			if not station.nextCounterClockwise.hasAnyTrain() then
				return false
			else
				moveTrain(train, station, station.nextCounterClockwise);
		);
		advanceIter(remainingTrains);
		return true;
	)
	pre
		exists1 s in set elems trackElements & isofclass(Station, s) and s.hasTrain(train);
		
	
	public advanceIter: set of Train ==> ()
	advanceIter(mvTrains) == (
		dcl movedTrains: set of Train := {};
		for all train in set mvTrains do (
			dcl trackElem: TrackElement := iota e in set elems trackElements & e.hasTrain(train);
			if isofclass(Station, trackElem) then
				movedTrains:= movedTrains union {train}
			else
				if train.dir = <CLOCKWISE> then (
					-- TODO
				)
				else (
					-- TODO
				)									
		)
		if card movedTrains = 0 then
			return
		else
			advanceIter(mvTrains \ movedTrains);
	)
	pre
		isClosed;
		
	private moveTrain: Train * Station * Block ==> ()
	moveTrain(train, src, dst) ==
		is not yet specified;
		
	private moveTrain: Train * Block * Station ==> ()
	moveTrain(train, src, dst) ==
		is not yet specified;
		
	private moveTrain: Train * Block * Block ==> ()
	moveTrain(train, src, dst) ==
		is not yet specified
	pre
		not dst.hasAnyTrain() and
		src.hasAnyTrain();
	
functions
	
traces
end Railway