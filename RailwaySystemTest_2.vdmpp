class RailwaySystemTest2 is subclass of Tester
	instance variables
 /*
	* Istance all variables used in tests
	* All the trackElements, including blocks, that are a standard rail, and stations with two rails
	* All trains used and helper variables
	*/
	
		railWay : Railway := new Railway();
		b1 : TrackElement := new Block();
		b2 : TrackElement := new Block();
		b3 : TrackElement := new Block();
		b4 : TrackElement := new Block();
		b5 : TrackElement := new Block();
		s1 : TrackElement := new Station();
		s2 : TrackElement := new Station();
		s3 : TrackElement := new Station();
		dummy : seq of TrackElement;
   	testRes : bool;
   	train: Railway`Train;
   	train2: Railway`Train;
   	
		
	operations
	
  /*
   * ----------------- RESET VARIABLES ----------------------
   * Reset all variables so they can be reused in all tests without conflicts 
   */
    private restartVariables: () ==> ()
    restartVariables() == 
    (
    	railWay := new Railway();
			b1 := new Block();
			b2 := new Block();
			b3 := new Block();
			b4 := new Block();
			b5 := new Block();
			s1 := new Station();
			s2 := new Station();
			s3 := new Station();
    );
    
  /*
   * ----------------- TWO ADJOIN STATIONS ----------------------
   * Append two stations in a row, wich isn't possible
   * -- SUPOSED TO FAIL
   */
    private testSubsequentStations: () ==> ()
    testSubsequentStations() ==
    (
    	restartVariables();
    	railWay.appendTrackElement(b1);
    	railWay.appendTrackElement(s1);
    	railWay.appendTrackElement(s2);
    );

  
  /*
   * ----------------- CLOSE TRACK ----------------------
   * Close a track with stations in both ends, wich isn't possible, because there will be two adjoin stations
   * -- SUPOSED TO FAIL
   */
    private testCloseTrack: () ==> ()
    testCloseTrack() ==
   	(
   		dcl tracks: seq of TrackElement;
   		restartVariables();
   		railWay.appendTrackElement(s1);
   		railWay.appendTrackElement(b1);
   		railWay.appendTrackElement(b4);
  		railWay.appendTrackElement(s2);
 			tracks := railWay.closeTrack();
 			
   	);
    
    ----- Test "A valid railway" -----	
    
  /*
   * ----------------- VALID RAILWAY ----------------------
   * Append four elements on a railway and check is length and
   * that all the trackElements are in the right order
   */
    private testValidRailway: () ==> ()
    testValidRailway() ==
    (
    	dcl tracks: seq of TrackElement;
   		restartVariables();
    	railWay.appendTrackElement(b1);
    	railWay.appendTrackElement(s1);
    	railWay.appendTrackElement(b4);
    	railWay.appendTrackElement(s2);
    	tracks := railWay.closeTrack();
    	assertTrue(len railWay.trackElements = 4);
    	assertTrue(tracks = [b1, s1, b4, s2]);
    );

  /*
   * ----------------- SEMAPHORES BEFORE STATION ----------------------
   * Create a railway with one station and check if the semaphores
   * before entering the station are yellow to warn trains that the next ones are red
   */
		testSemaphoreBeforeStation() ==
   	(
   		dcl tracks: seq of TrackElement;
   		restartVariables();
   		railWay.appendTrackElement(b1);
   		railWay.appendTrackElement(b2);
   		railWay.appendTrackElement(s1);
   		railWay.appendTrackElement(b4);
   		railWay.appendTrackElement(s2);
   		tracks := railWay.closeTrack();
   		assertTrue(b2.semaphoreClockwise = <YELLOW>);
   	);
   	
  /*
   * ----------------- PLACE A TRAIN ----------------------
   * Create a railway with one station and check if it's possible to place a train there
   */
   	testTrainPlacement() ==
   	(
   		dcl tracks: seq of TrackElement;
   		
   		restartVariables();
   		railWay.appendTrackElement(b1);
   		railWay.appendTrackElement(b3);
   		railWay.appendTrackElement(s1);
   		railWay.appendTrackElement(b4);
   		railWay.appendTrackElement(b5);
   		tracks := railWay.closeTrack();
   		
   		train := railWay.placeTrain(3,<CLOCKWISE>);
   		assertTrue(s1.hasAnyTrain());
   		
   	);
    
  /*
   * ----------------- SEMAPHORES IN EMPTY TRACK ----------------------
   * Create a railway with two stations and check if the semaphores
   * before entering one of them are YELLOW, the semaphores at the station are (allways) RED
   * and at a unocupied track are GREEN. There are no trains in the track
   */
    testSemaphoreEmptyTrack() ==
   	(
   		dcl tracks: seq of TrackElement;
   		
   		restartVariables();
   		railWay.appendTrackElement(b1);
   		railWay.appendTrackElement(b3);
   		railWay.appendTrackElement(b2);
   		railWay.appendTrackElement(s1);
   		railWay.appendTrackElement(b4);
   		railWay.appendTrackElement(s2);
   		tracks := railWay.closeTrack();
   		
   		assertTrue(s1.semaphoreClockwise = <YELLOW>);
   		assertTrue(s1.semaphoreCounterClockwise = <YELLOW>);
   		
   		assertTrue(b3.semaphoreCounterClockwise = <GREEN>);
   		assertTrue(b3.semaphoreCounterClockwise = <GREEN>);
   		
   		assertTrue(b4.semaphoreCounterClockwise = <RED>);
   		assertTrue(b2.semaphoreClockwise = <RED>);
   	);
   	 
   	 ----- Test "Semaphores colors when a train asks to leave the station" -----
  /*
   * ----------------- PERMISSION TO LEAVE ----------------------
   * Create a railway with two stations and check if the clockwise semaphore
   * before entering the occupied station is RED, the semaphores to leave the station are (allways) RED
   * and at a unocupied track are GREEN. When the train asks permission to leave the station,
   * the semaphore changes to GREEN, alowwing him to leave the station, turning back to RED
   * after he leaves the statino
   */	 	 	
   	testPermissionToLeave() ==
   	(
   		dcl tracks: seq of TrackElement;
   		
   		restartVariables();
   		railWay.appendTrackElement(b1);
   		railWay.appendTrackElement(b3);
   		railWay.appendTrackElement(b2);
   		railWay.appendTrackElement(s1);
   		railWay.appendTrackElement(b4);
   		railWay.appendTrackElement(s2);
   		tracks := railWay.closeTrack();
   		train := railWay.placeTrain(4, <CLOCKWISE>);
   		
   		assertTrue(s1.semaphoreClockwise = <RED>);
   		assertTrue(s1.semaphoreCounterClockwise = <YELLOW>);
   		
   		assertTrue(b2.semaphoreClockwise = <YELLOW>);
   		assertTrue(b2.semaphoreCounterClockwise = <RED>);
   		
   		assertTrue(b3.semaphoreClockwise = <GREEN>);
   		assertTrue(b3.semaphoreCounterClockwise = <GREEN>);
   		
   		assertTrue(b4.semaphoreClockwise = <RED>);
   		assertTrue(b4.semaphoreCounterClockwise = <RED>);
   		
   		assertTrue(railWay.askToLeaveStation(train));
   		
   		assertTrue(b4.semaphoreClockwise = <GREEN>);  		
   		railWay.advanceIter({train}); 	
   		assertTrue(b4.semaphoreClockwise = <RED>);  		
   	);
    
   
  /*
   * ----------------- TRAINS IN OPPOSITE DIRECTIONS  ----------------------
   * Create a railway with two stations and place two trains in opposite directions, 
   * so they're facing each other. After the first train asks for permission to leave,
   * it doesn't allow the second one to asks. It won't allow him to leave the station
   * untill the first train arrives at the station. Then, the permission will be granted
   * and he will leave the station.
   * after he leaves the statino
   */	 	 	
    	testTrainsBetweenStations() ==
   	(
   		dcl tracks: seq of TrackElement;
   		
   		restartVariables();
   		
   		railWay.appendTrackElement(b1);
   		railWay.appendTrackElement(b3);
   		railWay.appendTrackElement(b2);
   		railWay.appendTrackElement(s1);
   		railWay.appendTrackElement(b4);
   		railWay.appendTrackElement(s2);
   		tracks := railWay.closeTrack();
   		train := railWay.placeTrain(4, <CLOCKWISE>);
   		train2 := railWay.placeTrain(6, <COUNTER_CLOCKWISE>);   		
   		
 	   	assertTrue(s1.hasAnyTrain());
 	   	assertTrue(s2.hasAnyTrain());
   		assertTrue(railWay.askToLeaveStation(train));
   	
   		assertFalse(railWay.askToLeaveStation(train2)); 
   	
   	  railWay.advanceIter({train,train2});
   	  
 	   	assertTrue(b4.hasTrain(train));
 	   	assertTrue(s2.hasTrain(train2));
 	   	
 	    assertFalse(railWay.askToLeaveStation(train2));
			railWay.advanceIter({train,train2});
 			assertTrue(railWay.askToLeaveStation(train2));
 			railWay.advanceIter({train,train2});
 			
 			assertTrue(b4.hasTrain(train2));
 	   	assertTrue(s2.hasTrain(train));
   	);
   	

  /*
   * ----------------- TRAINS MOVING IN RAILWAY  ----------------------
   * Create a railway with three stations and place two trains in opposite directions, 
   * so they're NOT facing each other. The two trains ask permission to leave and advance
   * normally to the block ahead of them. There are stations between the two trains, so they 
   * can move normally in opposite directions
   */	 	 	   	 
   	  testIterTwoTrains() ==
   	(
   		dcl tracks: seq of TrackElement;
   		
   		restartVariables();
   		
   		railWay.appendTrackElement(b1);
   		railWay.appendTrackElement(b3);
   		railWay.appendTrackElement(s3);
   		railWay.appendTrackElement(b2);
   		railWay.appendTrackElement(s1);
   		railWay.appendTrackElement(b4);
   		railWay.appendTrackElement(s2);
   		tracks := railWay.closeTrack();
   		
   		train := railWay.placeTrain(5, <COUNTER_CLOCKWISE>);
   		train2 := railWay.placeTrain(7, <CLOCKWISE>);   		
   		
 	   	assertTrue(s1.hasAnyTrain());
 	   	assertTrue(s2.hasAnyTrain());
   		assertTrue(railWay.askToLeaveStation(train));
   		assertTrue(railWay.askToLeaveStation(train2));
   	
   		railWay.advanceIter({train,train2});

 	   	assertTrue(b2.hasAnyTrain());
 	   	assertTrue(b1.hasAnyTrain());
 		
   	);
   	
  /*
   * ----------------- TRAINS MOVING IN THE SAME DIRECTION ----------------------
   * Create a railway with two stations and place two trains in the same direction, 
   * one on each station. The first train asks to leave station and advance one iteration.
   * Just one train as moved, has the second train didn't asked for permission. Then the 2nd
   * train asks for permission to leave. Then the two trains move normally. Finally, has the
   * first train had stopped in the station, asks for permission, and advancing the two trains move
   * ahead, in adjoin trackElements.
   */	 	 
   	  test2TrainsRow() ==
   	(
   		dcl tracks: seq of TrackElement;
   		
   		restartVariables();
   		
   		railWay.appendTrackElement(b1);
   		railWay.appendTrackElement(s3);
   		railWay.appendTrackElement(b2);
   		railWay.appendTrackElement(s1);
   		railWay.appendTrackElement(b4);
   		railWay.appendTrackElement(b3);
   		tracks := railWay.closeTrack();
   		
   		train := railWay.placeTrain(2, <CLOCKWISE>);
   		train2 := railWay.placeTrain(4, <CLOCKWISE>);   		
   		
 	   	assertTrue(s3.hasAnyTrain());
 	   	assertTrue(s1.hasAnyTrain());
   		assertTrue(railWay.askToLeaveStation(train));
  	
   		railWay.advanceIter({train,train2});
 	   	assertTrue(b2.hasAnyTrain());
 	   	assertTrue(railWay.askToLeaveStation(train2));
 	   	
 	   	railWay.advanceIter({train,train2});
 	   	
 	   	assertTrue(s1.hasAnyTrain());
 	   	assertTrue(b4.hasAnyTrain());
 	   	
 	   	assertTrue(railWay.askToLeaveStation(train));
 	   	
 	   	railWay.advanceIter({train,train2});

 	   	assertTrue(b4.hasAnyTrain());
 	   	assertTrue(b3.hasAnyTrain());
 		
   	);
   	
  /*
   * ----------------- TRAIN STOPS AT RED ----------------------
   * Create a railway with two stations and place two trains in the same direction, 
   * one on each station, with just one block in the middle. The first train asks to leave station and
   * the semaphore turns YELLOW, has there a train 1one block ahead. After the first train have 
	 * advanced, the semaphore is RED because there's a train ahead. When you advance
	 * one iteration, the train doesn't move.
   */	 	
  	 	testStopsAtRed() ==
   	(
   		dcl tracks: seq of TrackElement;
   		
   		restartVariables();
   		railWay.appendTrackElement(b1);
   		railWay.appendTrackElement(b3);
   		railWay.appendTrackElement(s1);
   		railWay.appendTrackElement(b4);
   		railWay.appendTrackElement(s2);
   		railWay.appendTrackElement(b2);
   		
   		tracks := railWay.closeTrack();  
   		
   		train := railWay.placeTrain(3, <CLOCKWISE>);
   		train2 := railWay.placeTrain(5, <CLOCKWISE>);   		
   		
   		assertTrue(s1.hasAnyTrain());
 	   	assertTrue(s2.hasAnyTrain());
 	   	assertTrue(b4.semaphoreClockwise = <RED>);
   		assertTrue(railWay.askToLeaveStation(train));
   		assertTrue(b4.semaphoreClockwise = <YELLOW>);   
   		
   		railWay.advanceIter({train});
   		assertTrue(b4.hasCTrain()); 
   		assertTrue(s2.semaphoreClockwise = <RED>); 
   		
   		railWay.advanceIter({train});
   		assertTrue(b4.hasCTrain()); 
   		
   	);
   	
   	
  /*
   * ----------------- PLACE TWO TRAINS IN A STATION ----------------------
   * Create a railway with one station and place two trains in the oppositee directions, 
   * on the same station.
   */	 	
   	 	twoTrainsInStation() ==
   	(
   		dcl tracks: seq of TrackElement;
   		restartVariables();
   		
   		railWay.appendTrackElement(b1);
   		railWay.appendTrackElement(s1);
   		railWay.appendTrackElement(b4);
   		
   		tracks := railWay.closeTrack();  
 	
   		train := railWay.placeTrain(2, <CLOCKWISE>);
   		train2 := railWay.placeTrain(2, <COUNTER_CLOCKWISE>);   		
   		assertTrue(s1.hasCTrain());
			assertTrue(s1.hasCCTrain());

   	);
   	
   	
    public static main: () ==> ()
    main() ==
    (
      dcl tester: RailwaySystemTest2 := new RailwaySystemTest2();

      tester.testValidRailway();
      tester.testSemaphoreBeforeStation();
      tester.testTrainPlacement();
      tester.testPermissionToLeave();
      tester.testIterTwoTrains();
      tester.testStopsAtRed();
      tester.test2TrainsRow();
      tester.testTrainsBetweenStations();
      ------------------------------------------------------
      -- Uncomment a test call, one by one, to prove failure
      ------------------------------------------------------
      
      
      -- tester.testSubsequentStations();
  	  -- tester.testCloseTrack();
    );
    
end RailwaySystemTest2